<script src="/socket.io/socket.io.js"></script>
<script src="/js/jsencrypt.js"></script>
<script src="//ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
<script>


	var socket;
	var current_users = {};
	var minSafeModulus;

	function initWebSockets(){
		socket = io.connect(location.origin, {'connect timeout': 1000});

		socket.on('connect', function(){
			// add the user with the username and the generated public key
			socket.emit('adduser', $('#username').val(), crypt.getPublicKey());
		});

		socket.on('updatechat', function (username, data) {
			// if someone sends a chat message, append it to the conversation
			message = decryptMessage(data);
			$('#conversation').append('<b>'+username + ':</b> ' + message + '<br>');
		});

		socket.on('updateusers', function(new_username, users, old_username){
			console.log('users being udpated');
			// if a user is joining
			if(new_username){
				$('#conversation').append('<b>'+new_username + ':</b> has joined the room.<br>');	
			}
			// if a user is leaving
			else{
				$('#conversation').append('<b>'+old_username + ':</b> has left the room.<br>');
			}
			// update the current user/pubkey hash
			current_users = userListToHash(users);
			calculateMinModulus();
			updateTargetSelector();


			$('#pkeys').empty();
			for(key in current_users){
				$('#pkeys').append(key);
				$('#pkeys').append('<br>');
				$('#pkeys').append(current_users[key]);
				$('#pkeys').append('<br>');
			}
		});

		// listener, whenever the server emits 'updaterooms', this updates the room the client is in
		socket.on('updaterooms', function(rooms, current_room) {
			$('#rooms').empty();
			$.each(rooms, function(key, value) {
				if(value == current_room){
					$('#rooms').append('<div>' + value + '</div>');
				}
				else {
					$('#rooms').append('<div><a href="#" onclick="switchRoom(\''+value+'\')">' + value + '</a></div>');
				}
			});
		});
	}
	 
	function userListToHash(users){
		res = {};
		var i;
		for(i in users){
			splIndex = users[i].indexOf("-----BEGIN PUBLIC KEY-----");
			res[users[i].substring(0, splIndex)] = users[i].substring(splIndex);
		}
		return res;
	}

	function switchRoom(room){
		socket.emit('switchroom', room);
	}

	function updateTargetSelector(){
		var key;
		$('#targets').empty();
		for(key in current_users){
			$('#targets').append($('<option>').attr('value', key).text(key));
		}
	}
	// on load of page
	$(function(){
		$('#connect').click(function(){
			generateKeys();
			initWebSockets();
		});
		$('#send').click(function(){
			var data = encryptMessage($('#text').val(), $('#targets').val());
			socket.emit('sendchat', data);
		});
	});

	var garbagePadding = 5;
	function encryptMessage(data, target){
		pubkey = current_users[target];
		var crypto = new JSEncrypt();
		crypto.setPublicKey(pubkey);
		// encrypt returns the message both in BigInteger form (bi) and base16 string form (s)

		// TODO: check whether bi is greater than the lowest public key modulus

		var candidate;
		for (var i  = 0; i < 5; i++){
			candidate = randomGarbage(garbagePadding) + data;
			var enc_mess = crypto.encrypt(candidate);
			// if our garbage padded message is less than the minimum modulus, we're good!
			if(minSafeModulus.compareTo(enc_mess.bi) > 0){
				return enc_mess.s;
			}
			console.log('we had an unsafe message!');
		}

		return null;
	}

	function decryptMessage(data){
		decrypted_message = crypt.decrypt(data);
		if(decrypted_message){
			return decrypted_message.substring(garbagePadding);
		}
		return data;
	}

	function randomGarbage(n){
		garbage = [];
		for(var i = 0; i<n; i++){
			garbage.push(randomByte());
		}
		return String.fromCharCode.apply(String, garbage);
	}

	var crypt;
	function generateKeys(){
		// a keysize of 4096 will allow messages of up to 936 bits, or 117 characters
		var keySize = 1024;
		var crypto = new JSEncrypt({default_key_size: keySize});
		var dt = new Date();
		var time = -(dt.getTime());
		crypto.getKey();
		dt = new Date();
		time += (dt.getTime());
		$("#privKey").text(crypto.getPrivateKey());
		$("#pubKey").text(crypto.getPublicKey());
		crypt = crypto;
	}


	function calculateMinModulus(){
		var keys = Object.keys(current_users);	
		var crypto = new JSEncrypt();
		crypto.setPublicKey(current_users[keys[0]]);
		var minMod = crypto.key.n;
		for(var i = 1; i<keys.length; i++){
			crypto.setPublicKey(current_users[keys[i]]);
			minMod = crypto.key.n.min(minMod);
		}
		minSafeModulus = minMod;
	}


</script>
<p>Welcome to Cherry-Ripe</p>
<p id="rooms"></p>
<p id="conversation"></p>
<input id="text"></input>
<select id="targets"></select>
<button id="send">Send</button>

<br></br>

<input id="username"></input>
<button id="connect">Connect</button>
<p id="pkeys"></p>

<p id="privKey"></p>
<p id="pubKey"></p>